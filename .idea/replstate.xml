<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1491330402258">{:repl-history {:ide [], :local [&quot;(let [c (vec (range 100000))\n      s (* 0.2 (count c))\n      e (* 0.8 (count c))]\n  (time-multiple-avg 1000\n    (lsubseq c s e)))&quot; &quot;(let [c (vec (range 100000))\n      s (* 0.2 (count c))\n      e (* 0.8 (count c))]\n  (time-multiple-avg 1000\n    (doall (lsubseq c s e))))&quot; &quot;(let [c (vec (range 100000))\n      s (* 0.2 (count c))\n      e (* 0.8 (count c))]\n  (time-multiple-avg 1000\n    (doall (lsubseq2 c s e))))&quot; &quot;(/ 51.979080487 5.826008219)&quot; &quot;(let [c (vec (range 10000))\n      s (* 0.2 (count c))\n      e (* 0.8 (count c))]\n  (time-multiple-avg 10000\n    (doall (lsubseq c s e))))&quot; &quot;(let [c (vec (range 10000))\n      s (* 0.2 (count c))\n      e (* 0.8 (count c))]\n  (time-multiple-avg 10000\n    (doall (lsubseq2 c s e))))&quot; &quot;(/ 5.023890193700001 0.4934688236)&quot; &quot;()&quot; &quot;(let [c (vec (range 10000))\n      s (* 0.2 (count c))\n      e (* 0.8 (count c))]\n  (=\n    (lsubseq c s e)\n    (lsubseq2 c s (inc e))))&quot; &quot;(let [c (vec (range 10000))\n      s (* 0.2 (count c))\n      e (* 0.8 (count c))]\n  (=\n    (lsubseq c s e)\n    (lsubseq2 c s e)))&quot; &quot;(iterate-many [1 2 3] 5 #(conj % 0))&quot; &quot;(prn-str &lt;)&quot; &quot;(with-out-str (pr &lt;))&quot; &quot;(let [obj &lt;]\n  (= (with-out-str (pr obj))\n     (prn-str obj)))&quot; &quot;(let [obj \&quot;Hello\&quot;]\n  (= (with-out-str (pr obj))\n     (prn-str obj)))&quot; &quot;(let [obj \&quot;Hello\&quot;]\n  (do\n    (print (with-out-str (pr obj)))\n    (print (prn-str obj))))\n     &quot; &quot;ln&quot; &quot;(let [obj \&quot;Hello\&quot;]\n  (do\n    (println (with-out-str (pr obj)))\n    (println (prn-str obj))))\n     &quot; &quot;(let [obj &lt;]\n  (do\n    (println (with-out-str (pr obj)))\n    (println (prn-str obj))))\n     &quot; &quot;(let [obj &lt;]\n  (with-out-str (pr obj)))\n     &quot; &quot;(stringify-object &lt;)&quot; &quot;(let [obj &lt;\n      str-obj (stringify-object obj)\n      result (read-string str-obj)])&quot; &quot;(let [obj &lt;\n      str-obj (stringify-object obj)\n      result (read-string str-obj)]\n  (result 1 2))&quot; &quot;(let [obj &lt;\n      str-obj (stringify-object obj)\n      result (read-string str-obj)]\n  (result 5 6))&quot; &quot;(let [obj &lt;\n      str-obj (stringify-object obj)\n      result (read-string str-obj)]\n  (result 7 6))&quot; &quot;(let [obj &lt;\n      str-obj (stringify-object obj)\n      result (read-string str-obj)]\n  (result 8 6))&quot; &quot;(let [obj &lt;\n      str-obj (stringify-object obj)\n      result (read-string str-obj)]\n  result)&quot; &quot;(let [obj {:a 1 :b 2}\n      str-obj (stringify-object obj)\n      result (read-string str-obj)]\n  str-obj)&quot; &quot;(let [obj {:a 1 :b 2}\n      str-obj (stringify-object obj)\n      result (read-string str-obj)]\n  result)&quot; &quot;(let [obj (new-save-manager)\n      str-obj (stringify-object obj)\n      result (read-string str-obj)]\n  result)&quot; &quot;(let [obj (new-save-manager)\n      str-obj (stringify-object obj)\n      result (read-string str-obj)]\n  (type result))&quot; &quot;(let [obj (new-save-manager)\n      str-obj (stringify-object obj)\n      result (read-string str-obj)]\n  (save result result \&quot;t\&quot;))&quot; &quot;(with-out-str (pr obj))&quot; &quot;(let [obj (new-save-manager)\n      str-obj (with-out-str (pr obj))\n      result (read-string str-obj)]\n  (:extension result))&quot; &quot;(let [obj (new-save-manager)\n      str-obj (stringify-object obj)\n      result (read-string str-obj)]\n  (:extension result))&quot; &quot;(let [obj &lt;\n      str-obj (stringify-object obj)\n      result (read-string str-obj)]\n  (result 1 3))&quot; &quot;(let [obj &lt;\n      str-obj (stringify-object obj)\n      result (read-string str-obj)]\n  str-obj)&quot; &quot;(let [obj &lt;\n      str-obj (stringify-object obj)\n      result nil #_(read-string str-obj)]\n  str-obj)&quot; &quot;(let [obj (new-save-manager)\n      str-obj (stringify-object obj)\n      result nil #_(read-string str-obj)]\n  str-obj)&quot; &quot;(let [obj (new-save-manager)\n      str-obj (stringify-object obj)\n      [f s :as p] (clojure.string/split str-obj #\&quot; \&quot;)\n      result nil #_(read-string str-obj)]\n  p)&quot; &quot;(let [obj (new-save-manager)\n      str-obj (stringify-object obj)\n      [f s :as p] (clojure.string/split str-obj #\&quot; \&quot;)\n      result nil #_(read-string str-obj)]\n  f)&quot; &quot;(let [obj (new-save-manager)\n      str-obj (stringify-object obj)\n      [f s :as p] (clojure.string/split str-obj #\&quot; \&quot;)\n      result nil #_(read-string str-obj)]\n  s)&quot; &quot;(let [obj (symbol &lt;)\n      str-obj (stringify-object obj)\n      [f s :as p] (clojure.string/split str-obj #\&quot; \&quot;)\n      result nil #_(read-string str-obj)]\n  s)&quot; &quot;(let [f (read-string &lt;)]\n  (f 1 2))&quot; &quot;(let [f (read-string \&quot;&lt;\&quot;)]\n  (f 1 2))&quot; &quot;(let [f (read-string \&quot;&lt;\&quot;)]\n  (f 3 2))&quot; &quot;(let [f (read-string \&quot;&lt;\&quot;)]\n  f)&quot; &quot;(let [r (new-rand-gen 993061001)]\n  (time-multiple-avg 1000000\n    (random-int 0 1000000 r)))&quot; &quot;(let [r (new-rand-gen 993061001)]\n  (time-multiple-avg 100000000\n    (random-int 0 1000000 r)))&quot; &quot;(full-save-path\n  (new-save-manager \&quot;./parents\&quot; \&quot;test\&quot;)\n  \&quot;/1234/hello\&quot;)&quot; &quot;(full-save-path\n  (new-save-manager \&quot;./parents\&quot; \&quot;test\&quot;)\n  \&quot;1234/hello\&quot;)&quot; &quot;(time-multiple-avg 100\n  (iterate-many [] 100\n    (conj % 0)))&quot; &quot;(time-multiple-avg 100\n  (iterate-many [] 100\n    #(conj % 0)))&quot; &quot;(time-multiple-avg 10000\n  (iterate-many [] 1000\n    #(conj % 0)))&quot; &quot;(time-multiple-avg 10000\n  (iterate-many [] 10000\n    #(conj % 0)))&quot; &quot;(time-multiple-avg 10000\n  (iterate-many2 [] 10000\n    #(conj % 0)))&quot; &quot;(time-multiple-avg 100000\n  (iterate-many [] 5000\n    #(conj % 0)))&quot; &quot;(time-multiple-avg 100000\n  (iterate-many2 [] 5000\n    #(conj % 0)))&quot; &quot;(let [funcs [1 2 3 4 5]\n      times 2]\n  (take (* times (count funcs)) (interleave funcs)))&quot; &quot;(repeat (* times (count funcs)))\n&quot; &quot;(let [funcs [1 2 3 4 5]\n      times 2]\n  (repeat (* times (count funcs))))\n&quot; &quot;(time-mutliple-compare-avg 10\n  (Thread/sleep 500)\n  (Thread/sleep 1000))&quot; &quot;(time-pure (Thread/sleep 1000))&quot; &quot;(tst 1 2 3)&quot; &quot;(clojure.pprint/pprint\n  \&quot;[[1 [500.715851 499.660022 500.193015 500.318306 499.995259 500.838432 500.540443 500.355555 500.108359 500.151026]] [2 [1000.088719 1000.216042 1000.368423 1001.105267 1000.182856 1000.422602 1000.814728 1000.45511 1000.629162 1000.820146]]]\&quot;)&quot; &quot;(clojure.pprint/pprint\n  [[1 [500.715851 499.660022 500.193015 500.318306 499.995259 500.838432 500.540443 500.355555 500.108359 500.151026]] [2 [1000.088719 1000.216042 1000.368423 1001.105267 1000.182856 1000.422602 1000.814728 1000.45511 1000.629162 1000.820146]]])&quot; &quot;(clojure.pprint/pprint\n  (macroexpand-1\n    (time-mutliple-compare-avg 2\n      (do (Thread/sleep 500) 1)\n      (do (Thread/sleep 1000) 2))))&quot; &quot;(clojure.pprint/pprint\n  (macroexpand-1\n    '(time-mutliple-compare-avg 2\n      (do (Thread/sleep 500) 1)\n      (do (Thread/sleep 1000) 2))))&quot; &quot;(+ nil 1)&quot; &quot;(num nil)&quot; &quot;(num)&quot; &quot;(print '(1 2 3))&quot; &quot;(tst (+ 1 1))&quot; &quot;(tst (1 1))&quot; &quot;(tst (2 1))&quot; &quot;(time-mutliple-compare-avg 10\n  (do (Thread/sleep 500) 1)\n  (do (Thread/sleep 1000) 2))&quot; &quot;(clojure.pprint/pprint\n  (macroexpand-1\n    '(time-mutliple-compare-avg 2\n      (Thread/sleep 500)\n      (Thread/sleep 1000))))&quot; &quot;(clojure.pprint/pprint\n  (macroexpand-1\n    '(time-mutliple-compare-avg 100\n      (Thread/sleep 500)\n      (Thread/sleep 1000))))&quot; &quot;(clojure.pprint/pprint\n  (macroexpand-1\n    '(time-mutliple-compare-avg 10\n      (Thread/sleep 500)\n      (Thread/sleep 1000))))&quot; &quot;(time-mutliple-compare-avg 2\n      (Thread/sleep 500)\n      (Thread/sleep 1000))&quot; &quot;(time-mutliple-compare-avg 500\n      (Thread/sleep 123)\n      (Thread/sleep 456))&quot; &quot;(time-mutliple-compare-avg 100\n      (Thread/sleep 123)\n      (Thread/sleep 456))&quot; &quot;(pretty-expand (when true (println \&quot;Hello\&quot;)))&quot; &quot;(index)&quot; &quot;(pretty-expand-all (+ 1 (unpack [1 1])))&quot; &quot;(+ 1 (unpack [1 1]))&quot; &quot;(c/benchmark (Thread/sleep 10000))&quot; &quot;(c/bench (Thread/sleep 10000))&quot; &quot;(let [small-v (into [] (range 100000))\n      large-v (into [] (range 1000000000))]\n  (do\n    (c/bench (vec small-v))\n    (println \&quot;-----\&quot;)\n    (c/bench (vec large-v))))&quot; &quot;(let [small-v (into [] (range 1000))\n      large-v (into [] (range 1000000))]\n  (do\n    (c/bench (vec small-v))\n    (println \&quot;-----\&quot;)\n    (c/bench (vec large-v))))&quot; &quot;(bench (Thread/sleep 100))&quot; &quot;(ask-for-input \&quot;&gt;\&quot; \&quot;Error!\&quot; #(do true))&quot; &quot;keep&quot; &quot;gen-class&quot; &quot;(ask-for-input \&quot;&gt;\&quot; \&quot;Error!\&quot; #(do % true))&quot; &quot;(println)&quot; &quot;(ask-for-input \&quot;&gt;\&quot; \&quot;Error!\&quot; #(do (println %) true))&quot; &quot;(ask-for-input \&quot;&gt;\&quot; \&quot;Error!\&quot; #(do (println (nil? %) true)))&quot; &quot;(ask-for-input \&quot;&gt;\&quot; \&quot;Error!\&quot; #(do (println (nil? %)) true))&quot; &quot;(ask-for-input \&quot;&gt;\&quot; \&quot;Error!\&quot; #(do (println (type %)) true))&quot; &quot;(ask-for-input \&quot;&gt;\&quot; \&quot;Error!\&quot; #(do (println (type %)) false))&quot;], :remote []}}</component>
</project>